#### SELinux

1. ##### Введение

    Некоторые основы SELinux имеет смысл знать, хотя бы для того, чтобы смигрировать корневой раздел (получил ошибку **systemd-logind: Failed to start user slice user-1000.slice, ignoring: Access denied (org.freedesktop.DBus.Error.AccessDenied)**, правится с помощью операции SELinux **relabel**).

    SELinux определяет какому исходному домену разрешен доступ к целевому через управления контексными метками.

    Основные элементы:

     Policy Набор правил, которые определяют, какой источник имеет доступ к какой цели.

     Source domain Объект, который пытается получить доступ к цели. Обычно пользователь или процесс.

     Target domain То, к чему пытается обратиться исходный домен. Обычно это файл или порт.

     Context Метка безопасности, которая используется для классификации объектов в SELinux.

     Rule Определенная часть политики, которая определяет, какой исходный домен имеет какие права доступа к какому целевому домену.

     Labels То же, что и метка контекста, определенная для определения того, какой исходный домен имеет доступ к какому целевому домену. 

     Есть 3 основных режима SELinux: 

     - принудительный (enforcing);
     
     - разрешающий (permissive);
     
     - отключен (disabled);

    Чтобы поглядеть на наш статус SELinux используем команду `sestatus -v`, которая выведет все детали о SELinux, для переключения между режимами (разрешающий <-> принудительный): `setenforce 0|1`. Для перманентного применения настроек мы должны раскомментировать содержимое файла `/etc/sysconfig/selinux` и перезагрузить сервер.

2. ##### Метки контекста
 
    В SELinux есть такое понятие как метка (метка исходного домена, метка целевого домена), которая описывает следующие объекты:

    - файлы и каталоги

    - порты

    - процессы

    - пользователи

    А правила сопоставляют метки исходного и целевого доменов.

    Для определения меток:

    - файлы: `ls -Z`

    - процессы: `ps auZx`

    - сетевые демоны: `netstat -Ztulpen`

    Метки можно распознать следующим образом:

     *User:* user может быть распознан как _u в метке контекста; для большинства каталогов, установлено значение system_u.

     *Role:* role может быть распознана как _r в метке контекста. Большинство объектов помечены ролью object_r. В расширенном управлении SELinux конкретным пользователям SELinux могут быть назначены разрешения для определенных ролей SELinux.

     *Type:* контекст type может быть распознан как _t в метке контекста. Вы можете видеть, что к каталогам в / применяется широкий спектр типов контекста.

3. ##### Типы контекста

    Для определения типов контекста исполбзуют 2 команды:

    - `semanage` Команда semanage записывает новый контекст в политику SELinux, из которой он применяется к файловой системе.

    - `chcon`: эта команда предназначена для использования только в определенных случаях и обычно ее следует избегать. *Команда chcon записывает новый контекст в файловую систему, а не в политику. Все, что применяется с chcon, перезаписывается, когда файловая система перемаркируется (relabel), или исходный контекст восстанавливается из политики в файловую систему.* Не используйте эту команду!

    Пример установки контекста для каталога напримере Apache:

     - Узнаем исходный контекст:

    ```
    root@server1 /]# ls -Z /var/www
    drwxr-xr-x. root root system_u:object_r:httpd_sys_script_exec_t:s0 cgi-bin
    drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 html

    ```

    - Установим для данного контекста новый каталог (запишем его в политику безопасности SELinux):
    
    `semanage fcontext -a -t httpd_sys_content_t "/mydir(/.*)?"`

    - Установим для данного контекста новый каталог в политике безопасности на уровне ФС:

    `restorecon -R -v / mydir`

4. ##### Восстановление контекста файлов

    Правила при копировании файла в папку:

    - наследуются настройки контекста от родительской папки;

    - не наследуются, а сохраняются исходные, например, `cp -a`

    Для восстановления настроек файловых контекстов:

    `restorecon -Rv /`

    Или восстановление можно назначить на перезагрузку: создать файл `.autorelabel` в нужном каталоге (так решается ошибка **systemd-logind: Failed to start user slice user-1000.slice, ignoring: Access denied (org.freedesktop.DBus.Error.AccessDenied)** после миграции на новый раздел корневой системы - создадим в корне файл *.autorelabel* и перезагрузим сервер)

    TODO: продолжить с Использование логических (boolean) настроек для изменения настроек SELinux 

>[Links]
>1. [Управление SELinux] (https://max-ko.ru/14-upravlenie-selinux.html)
